/***********************************************************************************************************************
 This is a port of the code that is used to control the "Adafruit Bicolor LED Square Pixel Matrix" to C. Also functions
 to easily display characters on the LED matrix were added. You can find the original C++ code at
 https://github.com/adafruit/Adafruit-LED-Backpack-Library and the bicolor matrix at
 https://www.adafruit.com/products/902.

 Original work Copyright (c) 2012 Adafruit Industries
 Modified work Copyright (c) 2015 Tobias Trumm

 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit
 persons to whom the Software is furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all copies or substantial portions of the
 Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS
 OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
 OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **********************************************************************************************************************/
#include "Bicolor_Matrix.h"

#define HT16K33_BLINK_CMD 0x80
#define HT16K33_BLINK_DISPLAYON 0x01
#define HT16K33_CMD_BRIGHTNESS 0xE0

static const uint8_t BitReverseTable256[] =
		{
				0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0, 0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0,
				0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8, 0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8,
				0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4, 0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4,
				0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC, 0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC,
				0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2, 0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2,
				0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA, 0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,
				0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6, 0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6,
				0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE, 0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,
				0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1, 0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,
				0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9, 0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9,
				0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5, 0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,
				0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED, 0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,
				0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3, 0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3,
				0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB, 0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,
				0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7, 0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7,
				0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF, 0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF
		};


static const uint8_t FONT8x8[96][8] = {
		{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // space 0x20
		{0x30,0x78,0x78,0x30,0x30,0x00,0x30,0x00}, // !
		{0x6C,0x6C,0x6C,0x00,0x00,0x00,0x00,0x00}, // "
		{0x6C,0x6C,0xFE,0x6C,0xFE,0x6C,0x6C,0x00}, // #
		{0x18,0x3E,0x60,0x3C,0x06,0x7C,0x18,0x00}, // $
		{0x00,0x63,0x66,0x0C,0x18,0x33,0x63,0x00}, // %
		{0x1C,0x36,0x1C,0x3B,0x6E,0x66,0x3B,0x00}, // &
		{0x30,0x30,0x60,0x00,0x00,0x00,0x00,0x00}, // '
		{0x0C,0x18,0x30,0x30,0x30,0x18,0x0C,0x00}, // (
		{0x30,0x18,0x0C,0x0C,0x0C,0x18,0x30,0x00}, // )
		{0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00}, // *
		{0x00,0x30,0x30,0xFC,0x30,0x30,0x00,0x00}, // +
		{0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x30}, // ,
		{0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00}, // -
		{0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00}, // .
		{0x03,0x06,0x0C,0x18,0x30,0x60,0x40,0x00}, // / (forward slash)
		{0x3E,0x63,0x63,0x6B,0x63,0x63,0x3E,0x00}, // 0 0x30
		{0x18,0x38,0x58,0x18,0x18,0x18,0x7E,0x00}, // 1
		{0x3C,0x66,0x06,0x1C,0x30,0x66,0x7E,0x00}, // 2
		{0x3C,0x66,0x06,0x1C,0x06,0x66,0x3C,0x00}, // 3
		{0x0E,0x1E,0x36,0x66,0x7F,0x06,0x0F,0x00}, // 4
		{0x7E,0x60,0x7C,0x06,0x06,0x66,0x3C,0x00}, // 5
		{0x1C,0x30,0x60,0x7C,0x66,0x66,0x3C,0x00}, // 6
		{0x7E,0x66,0x06,0x0C,0x18,0x18,0x18,0x00}, // 7
		{0x3C,0x66,0x66,0x3C,0x66,0x66,0x3C,0x00}, // 8
		{0x3C,0x66,0x66,0x3E,0x06,0x0C,0x38,0x00}, // 9
		{0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x00}, // :
		{0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x30}, // ;
		{0x0C,0x18,0x30,0x60,0x30,0x18,0x0C,0x00}, // <
		{0x00,0x00,0x7E,0x00,0x00,0x7E,0x00,0x00}, // =
		{0x30,0x18,0x0C,0x06,0x0C,0x18,0x30,0x00}, // >
		{0x3C,0x66,0x06,0x0C,0x18,0x00,0x18,0x00}, // ?
		{0x3E,0x63,0x6F,0x69,0x6F,0x60,0x3E,0x00}, // @ 0x40
		{0x18,0x3C,0x66,0x66,0x7E,0x66,0x66,0x00}, // A
		{0x7E,0x33,0x33,0x3E,0x33,0x33,0x7E,0x00}, // B
		{0x1E,0x33,0x60,0x60,0x60,0x33,0x1E,0x00}, // C
		{0x7C,0x36,0x33,0x33,0x33,0x36,0x7C,0x00}, // D
		{0x7F,0x31,0x34,0x3C,0x34,0x31,0x7F,0x00}, // E
		{0x7F,0x31,0x34,0x3C,0x34,0x30,0x78,0x00}, // F
		{0x1E,0x33,0x60,0x60,0x67,0x33,0x1F,0x00}, // G
		{0x66,0x66,0x66,0x7E,0x66,0x66,0x66,0x00}, // H
		{0x3C,0x18,0x18,0x18,0x18,0x18,0x3C,0x00}, // I
		{0x0F,0x06,0x06,0x06,0x66,0x66,0x3C,0x00}, // J
		{0x73,0x33,0x36,0x3C,0x36,0x33,0x73,0x00}, // K
		{0x78,0x30,0x30,0x30,0x31,0x33,0x7F,0x00}, // L
		{0x63,0x77,0x7F,0x7F,0x6B,0x63,0x63,0x00}, // M
		{0x63,0x73,0x7B,0x6F,0x67,0x63,0x63,0x00}, // N
		{0x3E,0x63,0x63,0x63,0x63,0x63,0x3E,0x00}, // O
		{0x7E,0x33,0x33,0x3E,0x30,0x30,0x78,0x00}, // P 0x50
		{0x3C,0x66,0x66,0x66,0x6E,0x3C,0x0E,0x00}, // Q
		{0x7E,0x33,0x33,0x3E,0x36,0x33,0x73,0x00}, // R
		{0x3C,0x66,0x30,0x18,0x0C,0x66,0x3C,0x00}, // S
		{0x7E,0x5A,0x18,0x18,0x18,0x18,0x3C,0x00}, // T
		{0x66,0x66,0x66,0x66,0x66,0x66,0x7E,0x00}, // U
		{0x66,0x66,0x66,0x66,0x66,0x3C,0x18,0x00}, // V
		{0x63,0x63,0x63,0x6B,0x7F,0x77,0x63,0x00}, // W
		{0x63,0x63,0x36,0x1C,0x1C,0x36,0x63,0x00}, // X
		{0x66,0x66,0x66,0x3C,0x18,0x18,0x3C,0x00}, // Y
		{0x7F,0x63,0x46,0x0C,0x19,0x33,0x7F,0x00}, // Z
		{0x3C,0x30,0x30,0x30,0x30,0x30,0x3C,0x00}, // [
		{0x60,0x30,0x18,0x0C,0x06,0x03,0x01,0x00}, // \ (back slash)
		{0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00}, // ]
		{0x08,0x1C,0x36,0x63,0x00,0x00,0x00,0x00}, // ^
		{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF}, // _
		{0x18,0x18,0x0C,0x00,0x00,0x00,0x00,0x00}, // ` 0x60
		{0x00,0x00,0x3C,0x06,0x3E,0x66,0x3B,0x00}, // a
		{0x70,0x30,0x3E,0x33,0x33,0x33,0x6E,0x00}, // b
		{0x00,0x00,0x3C,0x66,0x60,0x66,0x3C,0x00}, // c
		{0x0E,0x06,0x3E,0x66,0x66,0x66,0x3B,0x00}, // d
		{0x00,0x00,0x3C,0x66,0x7E,0x60,0x3C,0x00}, // e
		{0x1C,0x36,0x30,0x78,0x30,0x30,0x78,0x00}, // f
		{0x00,0x00,0x3B,0x66,0x66,0x3E,0x06,0x7C}, // g
		{0x70,0x30,0x36,0x3B,0x33,0x33,0x73,0x00}, // h
		{0x18,0x00,0x38,0x18,0x18,0x18,0x3C,0x00}, // i
		{0x06,0x00,0x06,0x06,0x06,0x66,0x66,0x3C}, // j
		{0x70,0x30,0x33,0x36,0x3C,0x36,0x73,0x00}, // k
		{0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00}, // l
		{0x00,0x00,0x66,0x7F,0x7F,0x6B,0x63,0x00}, // m
		{0x00,0x00,0x7C,0x66,0x66,0x66,0x66,0x00}, // n
		{0x00,0x00,0x3C,0x66,0x66,0x66,0x3C,0x00}, // o
		{0x00,0x00,0x6E,0x33,0x33,0x3E,0x30,0x78}, // p 0x70
		{0x00,0x00,0x3B,0x66,0x66,0x3E,0x06,0x0F}, // q
		{0x00,0x00,0x6E,0x3B,0x33,0x30,0x78,0x00}, // r
		{0x00,0x00,0x3E,0x60,0x3C,0x06,0x7C,0x00}, // s
		{0x08,0x18,0x3E,0x18,0x18,0x1A,0x0C,0x00}, // t
		{0x00,0x00,0x66,0x66,0x66,0x66,0x3B,0x00}, // u
		{0x00,0x00,0x66,0x66,0x66,0x3C,0x18,0x00}, // v
		{0x00,0x00,0x63,0x6B,0x7F,0x7F,0x36,0x00}, // w
		{0x00,0x00,0x63,0x36,0x1C,0x36,0x63,0x00}, // x
		{0x00,0x00,0x66,0x66,0x66,0x3E,0x06,0x7C}, // y
		{0x00,0x00,0x7E,0x4C,0x18,0x32,0x7E,0x00}, // z
		{0x0E,0x18,0x18,0x70,0x18,0x18,0x0E,0x00}, // {
		{0x0C,0x0C,0x0C,0x00,0x0C,0x0C,0x0C,0x00}, // |
		{0x70,0x18,0x18,0x0E,0x18,0x18,0x70,0x00}, // }
		{0x3B,0x6E,0x00,0x00,0x00,0x00,0x00,0x00}, // ~
		{0x1C,0x36,0x36,0x1C,0x00,0x00,0x00,0x00}};// DEL

enum matrix_state
{
	CONNECTED,
	DISCONNECTED
};

struct _Matrix
{
	int file;
	uint8_t i2c_addr;
	uint8_t i2c_bus;
	uint8_t rotation;
	uint16_t displaybuffer[8];
	enum matrix_state state;
} typedef _Matrix;


uint8_t *bicolor_matrix_rotate_character(uint8_t rotation, char c);

void bicolor_matrix_draw_character(Matrix *m, char c, uint8_t font_color, uint8_t background_color)
{
	_Matrix *ma = (_Matrix *) m;
	if(c < 32 || c > 127)
	{
		return;
	}
	uint8_t index = c - 32;

	background_color = background_color % 4;
	font_color = font_color % 4;

	if(background_color == BICOLOR_MATRIX_LED_OFF)
	{
		bicolor_matrix_clear(m);
	}
	else if(background_color == BICOLOR_MATRIX_LED_RED)
	{
		for(int i = 0; i<8; i++)
		{
			// Turn on red LED
			ma->displaybuffer[i] |= 0xFF << 8;
			// Turn off green LED
			ma->displaybuffer[i] &= 0xFF00;
		}
	}
	else if(background_color == BICOLOR_MATRIX_LED_GREEN)
	{
		for(int i = 0; i<8; i++)
		{
			// Turn on green LED
			ma->displaybuffer[i] |= 0xFF;
			// Turn off red LED
			ma->displaybuffer[i] &= 0x00FF;
		}
	}
	else if(background_color == BICOLOR_MATRIX_LED_YELLOW)
	{
		for(int i = 0; i<8; i++)
		{
			// Turn on green and red LED
			ma->displaybuffer[i] |= 0xFFFF;
		}
	}

	uint8_t *letter = bicolor_matrix_rotate_character(ma->rotation, c);

	if(font_color == BICOLOR_MATRIX_LED_OFF)
	{

		for(int i = 0; i < 8; i++)
		{
			// Trun off green LED
			ma->displaybuffer[i] &= ~(letter[i]);
			// Turn off red LED
			ma->displaybuffer[i] &= ~(letter[i] << 8);
		}
	}
	else if(font_color == BICOLOR_MATRIX_LED_GREEN)
	{
		for(int i = 0; i < 8; i++)
		{
			// Trun on green LED
			ma->displaybuffer[i] |= letter[i];
			// Turn off red LED
			ma->displaybuffer[i] &= ~(letter[i] << 8);
		}
	}
	else if(font_color == BICOLOR_MATRIX_LED_RED)
	{
		for(int i = 0; i < 8; i++)
		{
			// Trun on red LED
			ma->displaybuffer[i] |= letter[i] << 8;
			// Turn off green LED
			ma->displaybuffer[i] &= ~(letter[i]);
		}
	}
	else if(font_color == BICOLOR_MATRIX_LED_YELLOW)
	{
		for(int i = 0; i < 8; i++)
		{
			// Trun on green LED
			ma->displaybuffer[i] |= letter[i] << 8;
			// Turn on red LED
			ma->displaybuffer[i] |= letter[i];
		}
	}
	free(letter);
}

uint8_t *bicolor_matrix_rotate_character(uint8_t rotation, char c)
{
	uint8_t *out = malloc(8*sizeof(uint8_t));
	uint8_t index = c - 32;
	for(int i = 0; i < 8; i++)
	{
		out[i] = 0x00;
	}
	if(rotation == 0)
	{
		for(int i = 0; i < 8; i++)
		{
			out[i] = BitReverseTable256[FONT8x8[index][i]];
		}
		return out;
	}
	else if(rotation == 1)
	{
		for(int i = 0; i < 8; i++)
		{
			for(int j = 0; j < 8; j++)
			{
				uint8_t bit = (FONT8x8[index][7-j] & (0x01 << (7-i))) >> (7-i);
				out[i] |= (bit << j);
			}
		}
		return out;
	}
	else if(rotation == 2)
	{
		for(int i = 0; i < 8; i++)
		{
			out[i] = FONT8x8[index][7-i];
		}
		return out;
	}
	else{
		for(int i = 0; i < 8; i++)
		{
			for(int j = 0; j < 8; j++)
			{
				uint8_t bit = (FONT8x8[index][j] & (0x01 << (i))) >> (i);
				out[i] |= (bit << j);
			}
		}
		return out;
	}
}

Matrix *bicolor_matrix_init_i2c_connection(uint8_t _addr, uint8_t _bus)
{
	_Matrix *ma =  malloc(sizeof(_Matrix));
	ma->state = DISCONNECTED;
	ma->i2c_addr = _addr;
	ma->i2c_bus = _bus;

	char filename[20];
	sprintf(filename, "/dev/i2c-%d", ma->i2c_bus);
	ma->file = open(filename, O_RDWR);
	if(ma->file < 0)
	{
		fprintf(stderr, "Error: Could not open file `%s': %s\n", filename, strerror(errno));
		if (errno == EACCES)
		{
			fprintf(stderr, "Run as root?\n");
		}
		bicolor_matrix_free((Matrix*) ma);
		exit(1);
	}
	if(ioctl(ma->file, I2C_SLAVE, ma->i2c_addr) < 0)
	{
		fprintf(stderr, "Error: Could not set address to 0x%02x: %s\n", ma->i2c_addr, strerror(errno));
		bicolor_matrix_free((Matrix*) ma);
		exit(1);
	}

	ma->rotation = 0;
	ma->state = CONNECTED;
	bicolor_matrix_clear((Matrix*) ma);
	return (Matrix*) ma;
}

void bicolor_matrix_close_i2c_connection(Matrix *m)
{
	_Matrix *ma = (_Matrix *) m;
	if(ma->state == CONNECTED)
	{
		close(ma->file);
		ma->state = DISCONNECTED;
	}
}

void bicolor_matrix_begin(Matrix *m)
{
	_Matrix *ma = (_Matrix *) m;
	//turn on oscillator
	i2c_smbus_write_byte(ma->file, 0x21);
	bicolor_matrix_blink_rate(m, BICOLOR_MATRIX_BLINK_OFF);
	// max brightness
	bicolor_matrix_set_brightness(m, 15);
}

void bicolor_matrix_set_brightness(Matrix *m, uint8_t b)
{
	_Matrix *ma = (_Matrix*) m;
	if(b > 15)
	{
		b = 15;
	}
	i2c_smbus_write_byte(ma->file, HT16K33_CMD_BRIGHTNESS | b);
}

void bicolor_matrix_blink_rate(Matrix *m, uint8_t b)
{
	_Matrix *ma = (_Matrix*) m;
	if(b > 3)
	{
		// turn off if not sure
		b = 0;
	}
	i2c_smbus_write_byte(ma->file, HT16K33_BLINK_CMD | HT16K33_BLINK_DISPLAYON | ( b << 1));
}

void bicolor_matrix_write_display(Matrix *m)
{
	_Matrix *ma = (_Matrix*) m;
	uint8_t data[16];
	for(uint8_t i = 0; i<8; i++)
	{
		data[2*i] = (uint8_t)(ma->displaybuffer[i] & 0xFF); // Green LED
		data[2*i+1] = (uint8_t)(ma->displaybuffer[i] >> 8);	// Red LED
	}
	uint8_t data_out[16];
	for(int i = 0; i < 16; i++)
	{
		data_out[i] = data[15-i];
	}

	i2c_smbus_write_i2c_block_data(ma->file, (uint8_t)0x00, 16, data);
}

void bicolor_matrix_clear(Matrix *m)
{
	_Matrix *ma = (_Matrix*) m;
	for(uint8_t i = 0; i < 8; i++)
	{
		ma->displaybuffer[i] = 0;
	}
}

void bicolor_matrix_draw_pixel(Matrix *m, int16_t x, int16_t y, uint16_t color)
{
	_Matrix *ma = (_Matrix*) m;
	if((y < 0) || (y >= 8)) return;
	if((x < 0) || (x >= 8)) return;

	color = color % 4;

	int16_t temp;
	switch(ma->rotation)
	{
		case 1:
			temp = x;
			x = y;
			y = temp;
			x = 8 - x - 1;
			break;
		case 2:
			x = 8 - x - 1;
			y = 8 - y - 1;
			break;
		case 3:
			temp = x;
			x = y;
			y = temp;
			y = 8 - y - 1;
			break;
	}
	if(color == BICOLOR_MATRIX_LED_GREEN){
		// Turn on green LED
		ma->displaybuffer[y] |= 1 << x;
		// Turn off red LED
		ma->displaybuffer[y] &= ~(1 << (x+8));
	}
	else if( color == BICOLOR_MATRIX_LED_RED)
	{
		// Turn on red LED
		ma->displaybuffer[y] |= (1 << (x+8));
		// Turn off green LED
		ma->displaybuffer[y] &= ~(1 << x);
	}
	else if(color == BICOLOR_MATRIX_LED_YELLOW)
	{
		// Turn on green and red LED
		ma->displaybuffer[y] |= (1 << (x+8)) | (1 << x);
	}
	else if(color == BICOLOR_MATRIX_LED_OFF)
	{
		// Turn off green and red LED
		ma->displaybuffer[y] &= ~(1 << x) & ~(1 << (x+8));
	}
}

void bicolor_matrix_set_rotation(Matrix *m, uint8_t r)
{
	_Matrix *ma = (_Matrix*) m;
	ma->rotation = r % 4;
}

void bicolor_matrix_free(Matrix *m)
{
	_Matrix *ma = (_Matrix*) m;
	if(ma->state == CONNECTED){
		bicolor_matrix_close_i2c_connection(m);
	}
	free(ma);
}
